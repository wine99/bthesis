% hfut.bib
% Encoding: UTF8

@article{McCarthy_1960, title={Recursive functions of symbolic expressions and their computation by machine, Part I}, volume={3}, ISSN={0001-0782, 1557-7317}, DOI={10.1145/367177.367199}, number={4}, journal={Communications of the ACM}, author={McCarthy, John}, year={1960}, month={Apr}, pages={184–195}, language={en} }

@phdthesis{Steele_1978, title={Rabbit: A compiler for scheme}, url={https://dl.acm.org/doi/10.5555/889478}, abstractNote={We have developed a compiler for the lexically-scoped dialect of LISP known as SCHEME. The compiler knows relatively little about specific data manipulation primitives such as arithmetic operators, but concentrates on general issues of environment and control. Rather than having specialized knowledge about a large variety of control and environment constructs, the compiler handles only a small basis set which reflects the semantics of lambda-calculus. All of the traditional imperative constructs, such as sequencing, assignment, looping, GO TO, as well as many standard LISP constructs such as AND, OR and COND, are expressed as macros in terms of the applicative basis set. A small number of optimization techniques, coupled with the treatment of function calls as GO TO statements, serves to produce code as good as that produced by more traditional compilers.}, note={Citation Key: steele1978rabbit}, school={Massachusetts Institute of Technology}, author={Steele, Guy L.}, year={1978} }

@inproceedings{Dybvig_2006, address={New York, NY, USA}, series={ICFP ’06}, title={The development of chez scheme}, ISBN={1-59593-309-3}, url={https://doi.org/10.1145/1159803.1159805}, DOI={10.1145/1159803.1159805}, abstractNote={Chez Scheme is now over 20 years old, the first version having been released in 1985. This paper takes a brief look back on the history of Chez Scheme’s development to explore how and why it became the system it is today.}, note={publisher-place: Portland, Oregon, USA
Citation Key: Dybvig2006chezscheme}, booktitle={Proceedings of the eleventh ACM SIGPLAN international conference on functional programming}, publisher={Association for Computing Machinery}, author={Dybvig, R. Kent}, year={2006}, pages={1–12}, collection={ICFP ’06} }

@book{Appel_1992, address={Cambridge}, edition={Repr}, title={Compiling with continuations}, ISBN={978-0-521-41695-5}, publisher={Cambridge Univ. Press}, author={Appel, Andrew W.}, year={1992}, language={en} }

@book{Queinnec_1996, address={Cambridge}, title={Lisp in Small Pieces}, ISBN={978-0-521-54566-2}, url={https://www.cambridge.org/core/books/lisp-in-small-pieces/66FD2BE3EDDDC68CA87D652C82CF849E}, DOI={10.1017/CBO9781139172974}, abstractNote={This is a comprehensive account of the semantics and the implementation of the whole Lisp family of languages, namely Lisp, Scheme and related dialects. It describes 11 interpreters and 2 compilers, including very recent techniques of interpretation and compilation. The book is in two parts. The first starts from a simple evaluation function and enriches it with multiple name spaces, continuations and side-effects with commented variants, while at the same time the language used to define these features is reduced to a simple lambda-calculus. Denotational semantics is then naturally introduced. The second part focuses more on implementation techniques and discusses precompilation for fast interpretation: threaded code or bytecode; compilation towards C. Some extensions are also described such as dynamic evaluation, reflection, macros and objects. This will become the new standard reference for people wanting to know more about the Lisp family of languages: how they work, how they are implemented, what their variants are and why such variants exist. The full code is supplied (and also available over the Net). A large bibliography is given as well as a considerable number of exercises. Thus it may also be used by students to accompany second courses on Lisp or Scheme.}, publisher={Cambridge University Press}, author={Queinnec, Christian}, editor={Callaway, Kathleen}, year={1996} }

@inproceedings{Sarkar_Waddell_Dybvig_2004, address={New York, NY, USA}, series={ICFP ’04}, title={A nanopass infrastructure for compiler education}, ISBN={1-58113-905-5}, url={https://doi.org/10.1145/1016850.1016878}, DOI={10.1145/1016850.1016878}, abstractNote={Compilers structured as a small number of monolithic passes are difficult to understand and difficult to maintain. Adding new optimizations often requires major restructuring of existing passes that cannot be understood in isolation. The steep learning curve is daunting, and even experienced developers find it hard to modify existing passes without introducing subtle and tenacious bugs. These problems are especially frustrating when the developer is a student in a compiler class.An attractive alternative is to structure a compiler as a collection of many small passes, each of which performs a single task. This “micropass” structure aligns the actual implementation of a compiler with its logical organization, simplifying development, testing, and debugging. Unfortunately, writing many small passes duplicates code for traversing and rewriting abstract syntax trees and can obscure the meaningful transformations performed by individual passes.To address these problems, we have developed a methodology and associated tools that simplify the task of building compilers composed of many fine-grained passes. We describe these compilers as “nanopass” compilers to indicate both the intended granularity of the passes and the amount of source code required to implement each pass. This paper describes the methodology and tools comprising the nanopass framework.}, note={Citation Key: 10.1145/1016850.1016878
publisher-place: Snow Bird, UT, USA}, booktitle={Proceedings of the ninth ACM SIGPLAN international conference on functional programming}, publisher={Association for Computing Machinery}, author={Sarkar, Dipanwita and Waddell, Oscar and Dybvig, R. Kent}, year={2004}, pages={201–212}, collection={ICFP ’04} }

@inproceedings{Keep_Dybvig_2013, address={New York, NY, USA}, series={ICFP ’13}, title={A nanopass framework for commercial compiler development}, ISBN={978-1-4503-2326-0}, url={https://doi.org/10.1145/2500365.2500618}, DOI={10.1145/2500365.2500618}, abstractNote={Contemporary compilers must typically handle sophisticated high-level source languages, generate efficient code for multiple hardware architectures and operating systems, and support source-level debugging, profiling, and other program development tools. As a result, compilers tend to be among the most complex of software systems. Nanopass frameworks are designed to help manage this complexity. A nanopass compiler is comprised of many single-task passes with formally defined intermediate languages. The perceived downside of a nanopass compiler is that the extra passes will lead to substantially longer compilation times. To determine whether this is the case, we have created a plug replacement for the commercial Chez Scheme compiler, implemented using an updated nanopass framework, and we have compared the speed of the new compiler and the code it generates against the original compiler for a large set of benchmark programs. This paper describes the updated nanopass framework, the new compiler, and the results of our experiments. The compiler produces faster code than the original, averaging 15-27% depending on architecture and optimization level, due to a more sophisticated but slower register allocator and improvements to several optimizations. Compilation times average well within a factor of two of the original compiler, despite the slower register allocator and the replacement of five passes of the original 10 with over 50 nanopasses.}, note={Citation Key: 10.1145/2500365.2500618
publisher-place: Boston, Massachusetts, USA}, booktitle={Proceedings of the 18th ACM SIGPLAN international conference on functional programming}, publisher={Association for Computing Machinery}, author={Keep, Andrew W. and Dybvig, R. Kent}, year={2013}, pages={343–350}, collection={ICFP ’13} }

@book{Siek_2022, title={Essentials of Compilation}, publisher={Massachusetts Institute of Technology Press}, author={Siek, Jeremy G.}, year={2022} }

@article{Knuth_1964, address={New York, NY, USA}, title={Backus normal form vs. Backus naur form}, volume={7}, ISSN={0001-0782}, DOI={10.1145/355588.365140}, note={Citation Key: 10.1145/355588.365140
tex.issue_date: Dec. 1964}, number={12}, journal={Communications of The Acm}, publisher={Association for Computing Machinery}, author={Knuth, Donald E.}, year={1964}, month={Dec}, pages={735–736} }

@article{Backus_Bauer_1960, address={New York, NY, USA}, title={Report on the algorithmic language ALGOL 60}, volume={3}, ISSN={0001-0782}, DOI={10.1145/367236.367262}, note={Citation Key: 10.1145/367236.367262
tex.issue_date: May 1960}, number={5}, journal={Communications of The Acm}, publisher={Association for Computing Machinery}, author={Backus, J. W. and Bauer, F. L. and Green, J. and Katz, C. and McCarthy, J. and Perlis, A. J. and Rutishauser, H. and Samelson, K. and Vauquois, B. and Wegstein, J. H. and van Wijngaarden, A. and Woodger, M. and Naur, Peter}, year={1960}, month={May}, pages={299–314} }
