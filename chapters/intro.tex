% !TeX root = ../main.tex

\chapter{绪论}

\section{课题背景}

当今世界计算机技术飞速发展，各种软件让人眼花缭乱，这得意于程序设计语言的发展。
常用的程序设计语言如 C 语言、C++ 语言、Java 语言等，
用这些高级语言编写程序极大提高了软件开发人员的效率。
但要使这些代码能真正被计算机识别并执行，
需要将它们转化成计算机指令，完成这一工作的便是编译器。
编译器将由高级语言编写的程序翻译成二进制代码或其他目标语言，并在特定平台上运行，
因此程序语言的发展，又很大程度上依赖编译技术的发展。

自上个世纪50年代以来，编译器的相关研究一直是计算机科学领域的一个活跃主题。
从目标机器的角度来说，目标机器处理器从单核到多核，其体系结构在不断的发生变化；
从程序语言的角度来说，高级程序语言在不断的丰富及扩展。

1954 年，John Backus 在 IBM 发明了 FORTRAN。
它是第一个广泛使用的具有功能实现的高级通用编程语言，而不仅仅是纸上的设计。
1957年，他领导的研究小组完成了 FORTRAN 编译器，
该编译器被普遍认为是引入了第一个明确完整的编译器。
1958年，John McCarthy 发明了 Lisp\cite{McCarthy_1960}，这是世界上第一门动态类型的函数式编程语言。
六十年代的 Simula 是第一门支持面向对象编程的语言，
其后继 Smalltalk ，一门纯面向对象的语言，在七十年代被发明。
1969 年至 1973 年，C 被发明，用作 Unix 操作系统的系统编程语言，流行至今。
Prolog，第一门逻辑编程语言，在 1972 年被发明。
1978年，ML 在 Lisp 之上建立了一个多态类型系统，开创了静态类型的函数式编程语言。
他们都产生了大量的后代，绝大多数现代编程语言都可以追溯回到这些语言。

作为最早的编程语言之一，Lisp 开创了计算机科学的许多理念，
比如树形数据结构，自动内存管理，动态类型，高阶函数，递归，自举，REPL 等等。
但函数式编程语言作为高度抽象的高级编程语言，与现代计算机的指令之间存在巨大的差别。
而传统的编译器课程只重点讲授教编译器的某几个阶段，如解析、语义分析和寄存器分配等。
这种方法的问题是很难理解整个编译器是如何结合在一起的，
为什么每个阶段是那样设计的，以及那些更具表达力的语言成分究竟是如何实现的。
本文实现了一个简单的 Lisp 方言，将其编译到x86汇编语言，以此来学习并探索编译技术。

\section{国内外研究现状}

Scheme 是一门极简主义 Lisp 方言，采用了词法作用域，
实现了尾递归优化，支持 first-class continuations 等。
1978 年，Guy Steele\cite{Steele_1978} 实现了第一个 Scheme 语言编译器，
该编译器也是第一个使用 CPS 作为中间表示的编译器。
1984 年，Kent Dybvig 创造了第一个商用 Scheme 编译器 Chez Scheme\cite{Dybvig_2006}，
它的编译速度很快，生成的目标代码也非常高效。
1992 年，Andrew Appel\cite{Appel_1992} 在其著作中描述了 Standard ML of New Jersey 的实现。
1994年，Christian Queinnec\cite{Queinnec_1996} 在他的书中全面地介绍了 Lisp 语言家族的语义和实现，
给出了 11 个解释器和 2 个目标语言分别为字节码和 C 语言的编译器。
2004 年，Kent Dybvig 等人\cite{Sarkar_Waddell_Dybvig_2004}
在印地安纳大学数年的编译器教学中演化提出了 nanopass 的思想。
2012 年，Andrew Keep\cite{Keep_Dybvig_2013} 在其论文中描述了 nanopass 框架
对商用编译器 Chez Scheme 的改造，论证了该框架的效率并不显著低于传统编译器结构。
2021 年，Jeremy Siek\cite{Siek_2022} 详细总结讲解了编译一个简单的函数式语言到机器语言的完整过程。

\section{本文工作}

本文的工作主要设计并实现了一个简单的 Lisp 方言，将其编译为 x86-64 汇编语言，
二者具体来说分别是 Typed Racket 和 x86-64 的严格子集。
语言支持的功能主要包括可变变量与循环，向量（元组）和垃圾回收，一等函数和闭包。

编译器前端利用了Lisp类语言方便的读取符号的特性和Racket的结构体来生成语法树，
这一步在“编译器前端设计实现”一章中说明。
编译器后端的主要流程包括去糖化，
变量唯一化，
赋值转换，
函数转换为闭包，
内存管理和垃圾回收，
原子化操作数，
显示化控制流，
生成汇编，
寄存器分配，
以及最后的收尾工作。
具体算法流程在“编译器后端设计实现”一章中给出。

本文还设计实现了一个简单的图形界面，允许我们在输入框中输入一段代码，并排展示出每一趟的编译结果，
输出使用图着色算法时生成的变量相关图以及最终的可执行文件。这一部分在“编译过程展示系统”一章中详细描述。

\section{本章小结}

作为最早的编程语言之一，Lisp 对后续的语言设计和发展产生了极大的影响，整个 Lisp 语言家族也在不断完善和发展。
在“课题背景”一节中，本章首先简要介绍了早期几个重要的编程语言的发展历程，Lisp 语言的地位和特性，
说明了实现一个 Lisp 语言的现实意义与背景。
“国内外研究现状”一节简要介绍了 Lisp 语言及其方言 Scheme 的发展历程，列出了关于其编译器构造的几篇重要文献。
然后指出了本文的编译器实现思想，即 Nanopass 相关的文献。
最后，“本文工作”一节中简要叙述了编译器从源语言到目标语言的各个环节，并给出了对应的章节安排。
