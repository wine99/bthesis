% !TeX root = ../main.tex

\chapter{目标语言}

The x86Int Assembly Language

用到的指令集

system v

本文使用 GNU 汇编器要求的 AT\&T x86-64 汇编语法。程序以 main 标签开始，后面跟着一系列指令。
globl 指令表明 main 过程是外部可见的，这是操作系统可以调用它的必要条件。
x86 程序存储在计算机的内存中。就本文的目的而言，计算机的内存是 64 位地址到 64 位值的映射。
计算机在 rip 寄存器中存储一个程序计数器 (PC) ，它指向下一条要执行的指令的地址。
对于大多数指令，程序计数器在指令执行后递增，因此它指向内存中的下一条指令。
大多数 x86 指令有两个操作数，每个操作数要么是一个整型常量 (称为立即数) ，
要么是一个寄存器 ，要么是一个内存位置。

寄存器是一种特殊的变量，每一个都有一个 64 位的值；
计算机中有 16 个通用寄存器，它们的名称在图\ref{fig:full-x86}给出。
我们使用 \% 符号后跟寄存器名，比如 \%rax，来指代某一个寄存器。

立即数使用语法 \$n 来指明，其中 n 是整数。
访问内存使用语法 n(\%r) 来指明，它的意思是拿到存储在寄存器 r 中的地址，然后给地址加 n 个字节。

我们来看一个简单但完整的 x86-64 程序示例。该程序计算式子\code{(+ 52 (- 10))}的值，
并将结果作为整个程序的返回值。

\begin{lstlisting}
start:
movq	$10, -8(%rbp)
negq	-8(%rbp)
movq	-8(%rbp), %rax
addq	$52, %rax
jmp conclusion

.globl main
main:
pushq	%rbp
movq	%rsp, %rbp
subq	$16, %rsp
jmp start
conclusion:
addq	$16, %rsp
popq	%rbp
retq
\end{lstlisting}

这个程序使用一个称为过程调用栈 (简称栈) 的内存区域。
堆栈由每个过程调用的独立帧组成。单个帧的内存布局如图\ref{fig:frame}所示。
寄存器 rsp 被称为堆栈指针 ，它指向堆栈顶部的项。
堆栈在内存中向下增长，通过减去堆栈指针来增加堆栈的大小。
在过程调用的上下文中，返回地址是调用方调用指令之后的指令。
函数调用指令 callq 在跳转到过程之前将返回地址压入堆栈。
寄存器 rbp 是 基指针 ，用于访问存储在当前过程调用帧中的变量。
调用者的基指针在返回地址之后被压入堆栈，然后基指针被设置为旧基指针的位置。
变量 1 存储在地址 −8(\%rbp) ，变量 2 存储在地址 −16(\%rbp) ，以此类推。

\begin{figure}[t]
	\centering
	\begin{tabular}{|r|l|} \hline
		位置 & 内容 \\ \hline
		8(\key{\%rbp}) & return address \\
		0(\key{\%rbp}) & old \key{rbp} \\
		-8(\key{\%rbp}) & variable $1$ \\
		-16(\key{\%rbp}) & variable $2$ \\
		\ldots  & \ldots \\
		0(\key{\%rsp}) & variable $n$\\ \hline
	\end{tabular}

	\caption{栈帧的内存布局}
	\label{fig:frame}
\end{figure}

回到这个程序，首先，操作系统发出一个 callq main 指令，
将其返回地址推送到堆栈上，然后跳转到 main 。
在 x86-64 中，堆栈指针 rsp 在执行任何 callq 指令之前必须整除 16 个字节。
因此当控制到达 main 时，rsp 偏离对齐 8 个字节 (因为 callq 压入返回地址)。

前三条指令是一个程序典型的准备工作。
指令 \code{pushq \%rbp} 将调用者的基指针保存到堆栈上，并从堆栈指针中减去 8 。
第二个指令 \code{movq \%rsp, \%rbp} 读取 rsp 中的内容，赋值给 rbp。
这条指令改变了基指针，使其指向旧基指针的位置。
指令 \code{subq \$16, \%rsp} 读取 rsp 中的内容，减去 16，再重新赋值给 rsp。
这条指令将堆栈指针向下移动，以便为存储变量留出足够的空间。

虽然这个程序只需要在栈上存储一个变量 (8 个字节) ，但是我们还是需要减去 16，
这样 rsp 是 16 字节对齐的，就可以调用其他函数。
准备工作的最后一条指令是 \code{jmp start}，
它使程序跳转到由 Racket 表达式 \code{(+ 52 (- 10))} 生成的指令，也就是 start 标签下的指令。

start 标签下的第一条指令是 \code{movq \$10, -8(\%rbp)}，
它将 10 存储在图\ref{fig:frame}中 variable 1 的位置。
指令 \code{negq -8(\%rbp)} 将值更改为 −10。下一条指令将 \%rax 中值更改为 -10。
最后，\code{addq \$52, \%rax} 将 52 加到 rax 上，将其值更新为 42。
我们总是约定将程序的返回值放在寄存器 rax 中。

conclusion 标签下的三个指令是一个程序典型的结束工作。
前两条指令将 rsp 和 rbp 寄存器恢复到过程开始时的状态。
指令 \code{addq \$16, \%rsp} 将栈指针移回指向旧的基指针。
然后 \code{popq \%rbp} 把旧基指针返回给 rbp，并在堆栈指针上加 8。
最后一条指令 retq 返回到调用它的过程，并在堆栈指针上加 8。
