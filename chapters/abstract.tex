% !TeX root = ../main.tex

\hfutsetup{
  keywords = {
    函数式编程语言，Lisp，编译器，Nanopass
  },
  keywords* = {
    Functional Programming Languages, Lisp, Compilers, Nanopass
  },
}

\begin{abstract}

\begin{comment}
  摘要分中文和英文两种，中文在前，英文在后，博士论文中文摘要一般 800～1500 个汉字，硕士论文中文摘要一般 500～1000 个汉字。
  英文摘要的篇幅参照中文摘要。

  关键词另起一行并隔行排列于摘要下方，左顶格，中文关键词间空一字或用分号“，”隔开，英文关键词之间用逗号“,”或分号“;”隔开。

  中文摘要是论文内容的总结概括，应简要说明论文的研究目的、基本研究内容、研究方法或过程、结果和结论，突出论文的创新之处。
  摘要应具有独立性和自明性，即不用阅读全文，就能获得论文必要的信息。
  摘要中不宜使用公式、图表，不引用文献。

  中文关键词是为了文献标引工作从论文中选取出来用以表示全文主题内容信息的单词和术语，一般 3～8 个词，要求能够准确概括论文的核心内容。
\end{comment}

函数式编程语言作为高度抽象的编程语言，与计算机的机器指令之间存在着巨大的差别。
作为计算机科学领域一门重要的基础学科，
学习构建编译器能让我们更深刻地理解软件与硬件之间的关联，指导我们编写正确高效的代码。

传统的编译器构造通常希望在一趟处理中完成尽可能多的工作，从而尽可能地缩短编译程序需要的时间。
但这种方案缺乏灵活性，难以展示或修改编译过程中的特定步骤，不利于编译原理的研究学习。
本文基于 Nanopass 思想，使用 Racket 语言，
充分利用 Pattern Matching 和 Structural Recursion，
实现了一个简单的静态类型 Lisp 方言的编译器，
并详细描述了从源程序到语法树再到汇编代码所涉及的各种算法。

本系统能够从文件中读取源程序代码，解析生成语法树，
历经十余趟变换后生成 x86-64 汇编程序，
然后与一个使用 C 语言实现的运行时一同链接生成可执行文件。
生成的可执行文件可以在类 Unix 系统下运行。
本文还设计了一个展示每一趟编译过程的中间结果的图形界面程序，
以此来可视化整个编译流程。

\end{abstract}

\begin{abstract*}

\begin{comment}
  This is a sample document of HFUT thesis \LaTeX{} template for bachelor,
  master and doctor. The template is created by \href{https://github.com/LaureatePoet}{LaureatePoet} and \href{https://github.com/HowardZorn}{Fw[a]rd}. The
  template meets the equirements of HFUT thesis writing standards.

  This document will show the usage of basic commands provided by \LaTeX{} and
  some features provided by the template. For more information, please refer to
  the template document hfutthesis-doc.pdf.
\end{comment}

  \noindent %西文首段不缩进
There is a huge gap between high-level programming languages
such as functional programming languages and machine instructions.
Compilers being a fundamental subject of the broad Computer Science,
learning how to build one will let us have a deeper understanding
of the relation between software and hardware,
guiding us to write correct and efficient code in the future.

Traditional compiler constructions typically want to do
as much work as possible in a single pass to minimize the time
it takes to compile a program. However, this approach lacks flexibility
and is difficult to display or modify a specific step in the
compilation process, which is not conducive to the study of compilers.
Based on the idea of Nanopass, this thesis implements
a simple statically typed Lisp dialect compiler
using the Racket programming language,
making intensive use of Pattern Matching and Structural Recursion.
Algorithms involved in all the way down to generate x86-64 assembly code
from syntax trees are presented in detail.

This system can parse the source code in a file to an abstract syntax tree,
and generate x86-64 assembly code after more than a dozen of passes of transformation.
The assembly code is then linked together with a runtime system implented in C,
generating an executable that can run in Unix-like systems.
This theis also designed a graphical user interface that shows
the intermediate results of each pass to visualize the entire compilation process.

\end{abstract*}
